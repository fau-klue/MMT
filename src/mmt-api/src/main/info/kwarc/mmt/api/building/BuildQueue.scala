package info.kwarc.mmt.api.building

import java.util.concurrent.ConcurrentLinkedDeque

import info.kwarc.mmt.api._
import info.kwarc.mmt.api.archives._
import info.kwarc.mmt.api.frontend._
import info.kwarc.mmt.api.modules.{DeclaredTheory, DeclaredView}
import info.kwarc.mmt.api.utils._
import info.kwarc.mmt.api.web._

import scala.collection.JavaConverters._
import scala.collection.mutable
import scala.util.Try



/** handles build tasks generated by a [[TraversingBuildTarget]] */
trait BuildManager extends Extension {
  def addTasks(/* up: Update,*/ qts: Iterable[BuildTask])
}

/** builds tasks immediately (no queueing, no dependency management, no parallel processing) */
class TrivialBuildManager extends BuildManager {
  def addTasks(/* up: Update,*/ qts: Iterable[BuildTask]) =
    qts.foreach { qt =>
      qt.target.runBuildTask(qt/*, up*/)
    }
}

abstract class QueuePolicy {
  def add(qt : BuildTask, qs : QueueState) : Unit
  def unblockTask(qt : BuildTask, bs : BuildResult, qs : QueueState) : Boolean
  def doBuildResult(br : BuildResult, qs : QueueState)
}

object QueuePolicy {
  def default = new QueuePolicy {
    def add(qt : BuildTask, qs : QueueState) = qs.queued.add(qt)
    def unblockTask(qt: BuildTask, bs: BuildResult, qs: QueueState): Unit = {
      bs match {
        case MissingDependency(_, _, _) if qs.blocked.contains(qt) =>
        case _ =>
          qt.missingDeps = qt.missingDeps diff bs.provided
      }
      qt.missingDeps.isEmpty
    }
    override def doBuildResult(br: BuildResult, qs: QueueState): Unit = ???
  }
}

class QueueState {
  // ******************* state

  /** the queue */
   val queued: ConcurrentLinkedDeque[BuildTask] = new ConcurrentLinkedDeque[BuildTask]
  /** tasks that were queued but are blocked due to missing dependencies; they are to be re-queued when the queue is empty */
   var blocked: List[BuildTask] = Nil
  /** true while the BuildQueue is processing the blocked tasks (i.e., after all queued tasks are built), whose missing dependencies could not be resolve */
   var processingBlockedTasks = false

  /** all queued tasks, indexed by their identifying data */
   val alreadyQueued: mutable.HashMap[BuildDependency, BuildTask] = new mutable.HashMap[BuildDependency, BuildTask]
  /** all built (successfully or permanently-failing) tasks since the last time the queue was empty, indexed by their identifying data */
   val alreadyBuilt: mutable.HashMap[BuildDependency, BuildResult] = new mutable.HashMap[BuildDependency, BuildResult]

  /** history of recent builds, used only for statistics/reporting */
   var recentlyBuilt: List[(BuildDependency, BuildResult)] = Nil

  // TODO unclear how this is used
   var currentQueueTask: Option[BuildTask] = None

  // TODO unclear how this is used
   var cycleCheck: Set[BuildDependency] = Set.empty

  /** the catalog mapping from (logical) resource dependency to build dependency */
  // TODO unclear how this is used
   val catalog: mutable.HashMap[ResourceDependency, BuildDependency] = new mutable.HashMap[ResourceDependency, BuildDependency]

  /** true if the BuildQueue should continue building */
   var continue: Boolean = true
  /** artificially slows down building by pausing before each task, useful for debugging */
   var pauseBeforeEachTask: Boolean = false
  /** time to pause when nothing to do */
   val pauseTime: Int = 2000
  /** true if the BuildQueue should destroy itself once it is empty (used to finish building when the main thread already terminated) */
   var stopOnEmpty: Boolean = false

  // clears the queue
   def clear {
    queued.clear
    alreadyBuilt.clear
    alreadyQueued.clear
    recentlyBuilt = Nil
    blocked = Nil
    currentQueueTask = None
    cycleCheck = Set.empty
  }

}

/** uses a queue of build tasks for multi-threaded execution, includes dependency management */
class BuildQueue extends ServerExtension("queue") with BuildManager {
  override def logPrefix: String = "queue"
  
  private object Queue extends QueueState
  
  import Queue._
  
  // ******************* main management interface

  /** adds the ServerExtension :queue and starts a separate thread for building */
  override def start(args: List[String]) {
    //controller.extman.addExtension(serve)
    buildThread.start
  }

  /** removes the ServerExtension and signals the build thread to terminate after the current task */
  override def destroy {
    //controller.extman.removeExtension(serve)
    synchronized {
      continue = false
    }
  }

  /** signals the build thread to terminate once the queue is empty, then waits for that */
  override def waitUntilRemainingTasksFinished {
    synchronized {
      stopOnEmpty = true
    }
    buildThread.join()
  }

  // ******************* task management (queuing and dequeuing)

  // TODO add policies here
  def addTasks(/* up: Update,*/ qts: Iterable[BuildTask]) {
    synchronized {
      qts.foreach(addTask(/*up,*/ _))
    }
  }

  /** adds a single task */
  private def addTask(/*up: Update,*/ qt: BuildTask) { /* TODO needs rewrite
    // qt.updatePolicy = up
    log("added:" + qt.toJString)
    val qtDep = qt.task.asDependency
    qt.willProvide.foreach(rd => if (catalog.contains(rd)) log(rd.toJString + " in " + catalog(rd).toJString)
    else catalog(rd) = qtDep)
    if (alreadyBuilt isDefinedAt qtDep) {
      if (qt.dependencyClosure) {
        // dependency of previous job: skip
        return
      } else {
        // new job: build anew
        alreadyBuilt -= qtDep
      }
    }
    if (alreadyQueued isDefinedAt qtDep) {
      if (qt.lowPriority) {
        // low priority: no need to add, skip
        return
      } else {
        // high priority: queue again but adjust updatePolicy
        val qt2 = alreadyQueued(qtDep)
        qt.merge(qt2)
        queued.remove(qt2)
        alreadyQueued -= qtDep
      }
    }
    // add to front/end of queue depending on priority
    if (qt.lowPriority) {
      queued.addLast(qt)
    } else {
      queued.addFirst(qt)
    }
    alreadyQueued(qtDep) = qt */
  }

  /** recursively queues all dependencies of the next task; then returns the head of the queue */
  private def getTopTask: List[Dependency] = synchronized {
    currentQueueTask = Option(queued.poll)
    currentQueueTask.foreach(qt => alreadyQueued -= qt.asDependency)
    currentQueueTask match {
      case None => Nil
      case Some(qt) => qt.missingDeps.filter {
        case PhysicalDependency(file) => !file.exists
        case _ => true
      }
    }
  }

  private def getNextTask: Option[BuildTask] = {
    val currentMissingDeps = getTopTask
    val (bDeps, rDeps) = currentMissingDeps.partition {
      case bd: BuildDependency => true
      case _ => false
    }
    val rDeps1 = rDeps.map { rd => (rd, rd match {
      case rs: LogicalDependency => catalog.get(rs)
      case _ => None
    })
    }
    val (lDeps1, fDeps1) = rDeps1.partition(_._2.isDefined)
    val fDeps = fDeps1.map(_._1)
    val lDeps = lDeps1.map(_._2.get)
    val bds = lDeps ++ bDeps.collect { case bd: BuildDependency => bd }
    if (currentMissingDeps.nonEmpty) {
      val qt = currentQueueTask.get // is non-empty if deps are missing
      currentQueueTask = None
      if (fDeps.nonEmpty) {
        qt.missingDeps = fDeps
        log("blocked: " + qt.toJString + ", missing: " + fDeps.mkString(", "))
        blocked = blocked ::: List(qt)
        getNextTask
      } else {
        qt.missingDeps = Nil
        queued.addFirst(qt)
        cycleCheck += qt.asDependency
        bds.foreach(t => buildDependency(/*qt.updatePolicy.forDependencies,*/ t))
        getNextTask
      }
    } else currentQueueTask
  }

  /** unblock previously blocked tasks whose dependencies have now been provided */
  private def unblockTasks(res: BuildResult,qt : BuildTask) {
    res match {
      case MissingDependency(_,_,_) if blocked.contains(qt) =>
      case _ =>
        blocked.foreach { bt =>
          bt.missingDeps = bt.missingDeps diff res.provided
        }
    }
    val (unblocked, stillBlocked) = blocked.partition(_.missingDeps.isEmpty)
    blocked = stillBlocked
    unblocked.foreach(u => log("Unblocked: " + u.inFile))
    if (unblocked.nonEmpty) recentlyBuilt ::= ((qt.asDependency,BuildEmpty("unblocked: " + unblocked.map(_.inFile).mkString(", "))))
    unblocked.reverseMap(queued.add)
  }

  // ******************* dependency handling

  /* not used yet - logical dependencies resolved in getNextTask via catalog, file dependencies not resolved yet */
  private def findResource(r: ResourceDependency): Option[FileBuildDependency] = r match {
    case PhysicalDependency(f) =>
      val (root, out) = controller.backend.resolveAnyPhysical(f).getOrElse(return None)
      controller.addArchive(root)
      val a = controller.backend.getArchive(root).getOrElse(return None)
      out match {
        case FilePath("export" :: key :: _) =>
          // a resource generated by an [[Exporter]]
          val exp = controller.extman.get(classOf[Exporter], key).getOrElse(return None)
          val in = exp.producesFrom(out).getOrElse(return None)
          val bd = FileBuildDependency(key, a, in)
          Some(bd)
        case fp if fp.startsWith(a.resolveDimension(source)) =>
          val imp = controller.extman.get(classOf[Importer], ???).getOrElse(return None) //TODO what importer to use?
        val in = imp.producesFrom(out).getOrElse(return None)
          val bd = FileBuildDependency(imp.key, a, in)
          Some(bd)
        case _ =>
          val catret = catalog.getOrElse(r,return None)
          Some(FileBuildDependency(catret.key,catret.archive,catret.inPath))
      }
    case LogicalDependency(mp) =>
      val catret = catalog.getOrElse(r,return None)
      Some(FileBuildDependency(catret.key,catret.archive,catret.inPath))
  }

  /** adds tasks for all dependencies of a task (given as a [[BuildDependency]])
    *
    * param up the update level for the dependency
    * @param bd build dependency to be added
    */
  private def buildDependency(/* up: Update,*/ bd: BuildDependency) = if (!cycleCheck.contains(bd)) {
    val tar = bd.getTarget(controller)
    val inFile = bd.archive / tar.inDim / bd.inPath
    val bt = bd match {
      case _: FileBuildDependency => tar.makeBuildTask(bd.archive, bd.inPath)
      case dbd: DirBuildDependency => tar.makeBuildTask(dbd.archive, dbd.inPath, dbd.children)
    }
    //val qt = new QueuedTask(tar, bt)
    // qt.lowPriority = false
    // qt.dependencyClosure = true
    addTask(/* up,*/ bt)
  }

  // ******************* the actual building

  def next : Unit = if (continue) {

  }

  def doBuildResult(res1 : BuildResult,qt : BuildTask) = {
    val res = res1 match {
      // let's assume for now that the estimation is better than the actual result
      case BuildSuccess(u, Nil) =>
        log("Success: " + qt.willProvide.mkString(", "))
        BuildSuccess(u, qt.willProvide)
      case bf@BuildFailure(use,pr) =>
        val newmissings = (queued.toArray(Nil.asInstanceOf[List[BuildTask]].toArray).toList :::
          blocked).flatMap(_.willProvide).filter(use.contains)
        if (newmissings.nonEmpty) MissingDependency(newmissings,pr,use) else bf
      case MissingDependency(md,pr,use) =>
        val newmissings = (queued.toArray(Nil.asInstanceOf[List[BuildTask]].toArray).toList :::
          blocked).flatMap(_.willProvide).filter(use.contains) ::: (md collect {
          case ld @ LogicalDependency(mp) if controller.getO(mp).isEmpty => ld
          case pd : PhysicalDependency => pd
        })
        MissingDependency(newmissings.distinct,pr,use)
      case _ => res1
    }
    val qtDep = qt.asDependency
    // if (!qt.dependencyClosure) cycleCheck -= qtDep
      currentQueueTask = None
      /* add two dummy results into the finished queue to show what happened to a blocked task */
    /*
      if (qt.forceRun.nonEmpty) {
        recentlyBuilt ::= (qtDep, BuildEmpty("was blocked"))
        recentlyBuilt ::= (qtDep, MissingDependency(qt.forceRun, qt.willProvide,qt.missingDeps))
      }
      recentlyBuilt ::= (qtDep, res)
      */ // incomprehensible to me
    res match {
      case _: BuildSuccess | _: BuildFailure | _: BuildEmpty =>
        // remember finished build
        if (!alreadyBuilt.isDefinedAt(qtDep)) {
          alreadyBuilt(qtDep) = res
        }
        recentlyBuilt ::= (qtDep,res)
        res.provided.foreach(catalog(_) = qtDep)
        log(res.getClass.getCanonicalName + ": " + qt.inFile)
      // TODO write file errors/.../file.deps
      // XML file containing used, provided, had errors
      case MissingDependency(missing, provided, used) =>
        // register missing dependencies and requeue
        /*
        qt.missingDeps = missing collect {
          case ld @ LogicalDependency(mp) if controller.getO(mp).isEmpty => ld
          case pd : PhysicalDependency => pd
        }
        */
        qt.missingDeps = missing
        log("Missing Deps: " + qt.missingDeps.mkString(", "))
        if (!processingBlockedTasks) {
          // qt.missingDeps = missing
          recentlyBuilt ::= (qtDep, BuildEmpty("was blocked"))
          blocked = blocked ::: List(qt)
        } else {
          recentlyBuilt ::= (qtDep, res)
        }
    }
    unblockTasks(res,qt)
    if (recentlyBuilt.length > 200) {
      recentlyBuilt = recentlyBuilt.take(200)
    }
  }

  
  /** the thread for building */
  private lazy val buildThread = new Thread {
    override def run {
      while (continue) {
        if (pauseBeforeEachTask) Thread.sleep(pauseTime)
        else {
          getNextTask match {
            case Some(qt) =>
              log("Doing " + qt.inFile)
              // TODO run this in a Future and track dependencies
              qt.errorCont.mark
              val res1 = qt.target.runBuildTask(qt/*, qt.updatePolicy*/)
              doBuildResult(res1,qt)
            case None =>
              // no next task in queue
              if (blocked.nonEmpty) {
                // process blocked tasks
                log("flush blocked tasks by ignoring their missing dependencies")
                processingBlockedTasks = true
                val qt = blocked.head
                // qt.forceRun = qt.missingDeps
                qt.missingDeps = Nil
                blocked = blocked.tail
                queued.add(qt)
              } else if (stopOnEmpty) {
                // signal termination
                continue = false
              } else {
                // pause and continue later
                if (currentQueueTask.isEmpty) {
                  cycleCheck = Set.empty
                  alreadyBuilt.clear
                  processingBlockedTasks = false
                }
                Thread.sleep(pauseTime)
              }
          }
        }
      }
    }
  }

  // ******************* web interface

  /** a ServerExtension for interacting with the queue through the browser */
    private def getQueueInfo: JSON = synchronized {
        val qSize = queued.size
        val iter = queued.iterator.asScala
        val num = 48
        val firsts = (if (qSize > num + 12) iter.take(num) else iter).toList.map(_.toJson)
        val hasMore = iter.hasNext
        val rest = if (hasMore) firsts :+ JSONString("and " + (qSize - num) + " more ...") else firsts
        val q = currentQueueTask.toList.map(q => JSONString("running: " + q.toJString)) ++ rest
        val bs = blocked.map(_.toJson)
        val fs = recentlyBuilt.map {
          case (d, r) =>
            JSONObject("dependency" -> d.toJson, "result" -> r.toJson)
        }
        JSONObject("count" -> JSONInt(qSize),
          "queue" -> JSONArray(q: _*),
          "blocked" -> JSONArray(bs: _*),
          "finished" -> JSONArray(fs: _*))
    }

    def apply(request: ServerRequest): ServerResponse = request.path match {
      case List("clear") =>
        clear
        ServerResponse.JsonResponse(JSONNull)
      case List("pause") =>
        // toggles pausing
        pauseBeforeEachTask = !pauseBeforeEachTask
        ServerResponse.JsonResponse(JSONBoolean(pauseBeforeEachTask))
      case List("targets") =>
        // list all targets
        val targets = "mmt-omdoc" :: controller.getConfig.getEntries(classOf[ExtensionConf]).collect {
          case ExtensionConf(key, cls, args) if classOf[BuildTarget].isAssignableFrom(Class.forName(cls)) => key
        }
        ServerResponse.JsonResponse(JSONArray(targets.map(JSONString): _*))
      case List("archives") =>
        val as = controller.backend.getArchives.map(a => a.archString)
        ServerResponse.JsonResponse(JSONArray(as.map(JSONString): _*))
      case _ =>
        ServerResponse.JsonResponse(getQueueInfo)
    }
}
